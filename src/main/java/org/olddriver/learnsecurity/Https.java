package org.olddriver.learnsecurity;

/**
 * http over ssl
 * 20210908
 * 第五部分
 */
public class Https {
    /**
     * http协议的报文在互连网传输过程中，可能在中间节点被修改或响应被中间节点伪造
     * https对传输内容进行加密，防止被中间节点篡改
     *
     * 对称加密
     * 通信双方加解密时使用相同密钥
     * 非对称加密
     * 通信双方加解密时使用不同密钥
     *
     * 数据包中报文使用非对称加密，中间节点获取公开公钥后就可以偷窥响应。使用对称加密，只要密钥不泄露中间节点就无法偷窥
     * 为保证对称加密密钥不泄露，客户端向服务端发送密钥过程中使用非对称加密的公钥加密。
     * 服务端在下发非对称加密公钥时，公钥可能在下发过程中被篡改，客户端无法判断公钥真伪，因此服务器事先使用ca机构的私钥加密服务端公钥生成证书下发客户端
     * 客户端使用操作系统中内嵌的ca公钥解密证书，获取服务端公钥，使用公钥加密对称加密密钥发送服务端
     *
     * https四次握手
     * 客户端请求服务端，告知支持的对称加密算法
     * 服务端响应请求，下发证书
     * 客户端生成对称加密密钥，使用公钥加密发送服务端
     * 服务端给予响应
     * 经过四次握手后，双方在80端口进行对称加密通信
     *
     * SSL剥离攻击
     * 用户输入url一般不携带协议名，默认发送http请求，服务器会要求客户端重定向到https地址。但最初的http请求导致漏洞
     * 中间节点可以篡改响应，要求客户端重定向到http地址
     *
     * 生成自签名证书内网使用https
     * 下载openssl
     * 生成服务端私钥
     * 根据私钥创建证书签名请求文件(csr文件)，文件中包含服务端公钥及服务端信息
     * 自建ca，生成ca私钥，ca证书签名请求文件，ca证书签名请求文件中包含ca机构信息
     * 根据ca证书签名请求文件生成ca根证书
     * 使用ca私钥，ca根证书对服务端证书签名请求文件进行签名，生成服务端证书
     * 将服务端私钥，服务端证书上传服务端；在服务器上安装ca根证书可以使用https
     * 使用服务端私钥和服务端证书无法给其他服务端证书签名请求文件签名
     *
     */
}
