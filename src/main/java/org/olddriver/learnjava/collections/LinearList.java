package org.olddriver.learnjava.collections;

/**
 * 线性表
 * 20200826
 * 第三部分
 */
public class LinearList {
    /**
     * 线性表(最常用的线性结构)
     * 由n个数据元素a1,a2,...an组成的有限序列称为线性表。
     * n为表的长度；n=0时，将线性表称为空表；n>0时，记作(a1,a2,...,an)
     * 表中元素最多只有一个直接前趋，一个直接后继
     * 线性表特点
     * 线性表中元素具有下标，表示元素在表中的位置
     * 相邻元素具有序偶关系
     * 表中元素可以是简单类型，也可以是复杂类型。数据元素为复杂类型时，数据元素可由多个数据项组成，此时数据元素称为记录，
     * 含有大量记录的线性表称为文件
     *
     * 顺序表 Sequence List
     * 使用一组连续存储空间存储线性表中元素，线性表中逻辑相邻的元素，物理上也相邻
     *
     * 特点
     * 第一个元素的存储位置称为基地址，若已知某个元素的存储位置，可以计算出其余元素的存储位置
     * 随机存取
     * 通过下标可以访问任意位置元素，称为随机存取
     *
     * 顺序表实现
     * 可使用一维数组存储元素，使用一变量记录表长
     *
     * 顺序表操作
     * 按值查找
     * 顺序查找，遍历表中元素，平均查找长度(ASL)等于查找第i个元素的概率乘以查找第i个元素需比较的次数最后求和，
     * 假设等概率查找每个元素，ASL = 1/n * 1 + 1/n * 2 + ... + 1/n * n = (n+1)/2
     * 插入
     * i.插入最后位置 直接将数据插入数组指定位置，最理想情况
     * ii.插入中间位置 从终端元素到插入位置元素后移一位，再插入元素，平均情况
     * iii.插入最前位置 从终端元素到起始元素后移一位，再插入元素，最坏情况
     * 删除
     * i.删除最后一个元素 直接将元素删除，最理想情况
     * ii.删除中间位置元素 将元素删除，删除元素后的所有元素前移一位，平均情况
     * iii.删除起始元素 将起始元素删除，其后所有元素前移，最坏情况
     *
     * 链表
     * 线性表的链式存储结构。使用一组任意存储单元存放表示元素，元素的逻辑次序与物理次序不一定相同
     * 元素存放在结点中。每个结点都由数据域和指针域构成，数据域存放数据元素，指针域存放地址
     * 特点
     * 顺序存取
     * 链表访问元素必须从头指针开始，顺序访问每个结点，称为顺序存取
     * 分类
     * 单链表 结点中仅有一个指针域
     * 双链表 结点中包含两个指针域
     * 循环链表 尾节点指针域存放头结点地址
     * 相关概念
     * 头指针 指向链表中第一个结点的指针
     * 首元结点 存放线性表中第一个元素的结点
     * 头结点 链表中第一个节点，附加在首元结点前；添加头结点，使对首元结点的操作与其他结点一致
     * 空单链表表示
     * 不带头结点的空单链表，头指针为null，表示空链表
     * 带头结点的空单链表，头结点的指针域为null，表示空链表
     *
     * 带头结点单链表实现
     * 使用头指针确定单链表，头指针中存储头结点地址。java中头指针为结点类型引用
     * 单链表操作
     * 初始化
     * 创建头结点，将头结点的地址存储在头指针中
     * 将头结点指针域设置为null
     * 判断链表是否为空
     * 判断头结点指针域是否为空
     * 销毁链表
     * 使用临时变量存储头指针中地址，头指针存储头结点指针域中的地址，销毁临时变量指向的结点。重复操作，直到头指针为null
     * 清空链表
     * 使用临时变量p，q存储地址，最初p存放首元结点地址，q存放首元结点后继地址；若p不是空，可以删除p指向的结点，将q赋给p，将p的指针域赋给q；继续判断p是否为空，p为空表示所有结点删除完毕；
     * 最后将头结点指针域设置为空
     * 链表表长
     * 使用临时变量p存储地址，最初p存放首元结点地址；若p不是空，结点个数加1，将p的指针域赋给p；继续判断p是否为空，若p为空到达链表结尾
     * 不再循环
     * 获取第i个元素
     * 顺序访问链表所有元素，使用变量p记录地址，变量i记录结点个数，当结点个数等于查找的元素位置，
     * 按值查找
     * 顺序访问链表中所有结点，使用p记录地址，若p不为空且p的数据域与指定值不等，p向后移动一位，继续判断；循环结束后返回p
     * 找到则返回地址，不存在返回null
     * 在i结点前插入
     * 新建结点；顺序访问到链表中第i-1个结点，将第i-1个结点的指针域赋给新节点指针域，将新节点地址赋给第i-1个结点指针域
     * 删除第i个结点
     * 顺序访问到链表中第i-1个结点，将第i-1个结点指针域存储在临时变量中，将第i个结点的指针域赋值给第i-1个结点的指针域；
     * 销毁第i个结点
     * 头插法创建单链表
     * 创建空链表。反向读取数据，每读取一个数据，创建一个新结点，将数据存储在数据域中，指针域设为null，将头结点指针域赋值给新结点指针域，
     * 将新结点地址赋值给头结点指针域。直至读取完所有数据
     * 尾插法创建单链表
     * 创建空链表。创建尾指针，将头指针赋值给尾指针。
     * 正向读取数据，每读取一个数据，创建一个新结点，将数据存放在数据域中，将指针域设为null，将新结点的地址赋值给尾指针的next域，
     * 将新结点地址赋值给尾指针
     *
     * 循环链表优点
     * 从表中任意一个结点出发，都能找到表中其他结点
     * 带头指针的单空循环链表实现
     * 创建头结点，将头结点的地址赋值给头指针；将头指针赋值给头结点的指针域
     * 若频繁操作循环链表的头尾结点，用尾指针表示链表优于用头指针表示循环链表
     * 单循环链表操作
     * 合并两个带尾指针的单循环链表
     * 定义指针p指向A链表的头结点，将B链表的首元结点地址赋给A链表尾结点指针域，销毁B链表的头结点，将p指针赋给B链表的尾结点指针域
     *
     * 双向链表优点
     * 可以直接获取某个结点的直接前趋，直接后继
     * 双向链表的结点中包括前趋指针域，后继指针域，数据域
     * 带头结点空双向链表表示
     * 创建头结点，头结点的前趋指针域，后继指针域赋值为null，将头结点的地址赋给头指针
     * 双向循环链表
     * 尾结点的后继指针域指向头结点，头结点的前趋指针域指向尾结点
     * 带头结点的空双向循环链表表示
     * 头结点的后继指针域指向自身，头结点的前趋指针域指向自身
     * 双向链表对称性
     * 某个结点的前趋结点的后继是当前结点，某个结点的后继结点的前趋是当前结点
     * 双向链表操作
     * 双向链表插入，删除操作与单链表不同，其余操作与单链表类似
     * 在第i个结点前插入
     * 顺序访问链表中结点，查找到第i个结点，使用指针p指向第i个结点。创建新结点，使用指针s指向新结点
     * 将p的前趋指针域赋给s的前趋指针域，将p赋给s的后继指针域；将s赋给p的前趋指针的后继指针域，将s赋给p的前趋指针域
     * 删除第i个位置元素
     * 顺序访问链表中结点，查找到第i个结点，使用指针p指向第i个结点。
     * 将p结点的后继指针域赋给p的前趋指针的后继指针域，将p的前趋指针域赋给p的后继指针的前趋指针域
     * 销毁指针p指向结点
     *
     * 有序表(有序线性表)
     * 有序表合并
     * 使用顺序表实现
     * 创建新顺序表。使用两个变量存放元素索引，初始值为0。
     * 比较两个表中指定索引处的元素，将较小的元素加入新表，将存放较小元素索引的变量加一；继续比较指定索引处元素，直到到达某个顺序表的尾部；
     * 将未到达末尾表中元素全部加入到新表中
     * 使用链表实现
     * 使用pa，pb指针分别指向两个链表的首元结点，使用pc指针指向a链表的头结点。比较pa，pb指针指向结点的数据域，将数据域较小结点放置在pc
     * 结点之后，指向较小结点的指针后移，pc后移；继续比较pa，pb两指针指向的结点，直到到达某个链表尾部；将未到达尾部的链表中剩余结点放值在pc后
     * 释放b链表头结点
     */
}
