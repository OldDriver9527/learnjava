package org.olddriver.learnjava.generics;

/**
 * 20200808
 * 泛型
 */
public class Generics<T> {
    /**
     * 泛型
     * 指泛型类型和泛型方法
     *
     * 泛型类型(Generic Type)
     * 声明类型时，若某些类型不确定，可以声明形式类型参数(formal type parameter)引入类型变量，
     * 调用时再声明实际类型参数(actual type argument)，使用具体类型替换类型变量。
     * 实例化泛型类型
     * 创建泛型类型实例时，需用实际类型参数替换类型变量。
     * 如果不声明实际类型参数创建的类型属于原始类型(Raw Type)，非泛型类型不属于原始类型
     * 为了向前兼容，可将泛型类型变量赋值给原始类型变量
     * 将原始类型变量赋值给泛型类型变量，会产生警告
     *
     * 泛型方法(Generic Method)
     * 在方法声明时，无法确定形参类型可以声明形式类型参数引入类型变量，
     * 在调用方法时声明实际类型参数，用具体类型替换类型变量。
     * 形式类型参数在返回值之前声明
     * 类型变量仅在方法中有效
     * 静态方法无法使用类或接口上的类型变量，若希望使用类型变量，必须将方法定义为泛型方法
     * 调用泛型方法时可以在句点与方法名间显示指明实际类型参数列表，也可省略
     *
     * 类型变量边界
     * 类型变量默认具有Object类中行为，想为类型变量添加行为，为类型变量指定上界，使用extends定义类型变量上界。
     * 可以为类型变量定义多个上界，多个上界用&连接，多个上界中只能有一个类，可以有多个接口。类位于接口之前
     * 类型变量不能定义下界
     *
     * 泛型类型变量传递
     * 一般泛型类型变量，当实际类型参数不一致不能相互赋值，需用通过通配符放宽实际类型参数范围
     * 通配符分为上界通配符，无界通配符，下界通配符
     * 上界通配符(? extends Demo)表示上界及其子类类型
     * 无界通配符(?)表示任意类型
     * 下界通配符(? super Demo)表示下界及其父类类型
     *
     * 泛型擦除
     * 将泛型类，泛型接口，泛型方法中类型变量替换为第一边界，若未指定边界替换为Object
     */
}
