package org.olddriver.learnjava.generics;

import java.util.HashMap;
import java.util.Map;

/**
 * 20200808
 * 泛型
 */
public class Generics<T> {
    /**
     * 泛型类型(Generic Type)   类型或方法声明中包含若干类型变量
     * 将类型或方法声明中不确定的类型使用类型变量表示，类型变量通过声明形式类型参数(formal type parameter)引入
     * 调用时使用实际类型参数(actual type argument)替换形式类型参数。
     *
     * 实例化泛型
     * 创建泛型实例时，需执行泛型调用，即用实际类型参数列表替换形式类型参数列表。
     * 具有实际类型参数列表的泛型称为参数化类型(Parameterized Type)
     * 缺少实际类型参数列表的泛型称为原生类型(Raw Type)
     *
     * 泛型方法(Generic Method)
     * 在方法声明中包含形式类型参数列表，该方法就转变为泛型方法。
     * 泛型方法拥有自己的类型变量，类型变量仅在方法中有效。形式类型参数列表位于返回值之前
     * 静态方法无法使用类或接口上的类型变量，若希望使用类型变量，必须将方法定义为泛型方法
     * 调用泛型方法时可以在句点与方法名间显示指明实际类型参数列表，也可省略
     *
     * 类型变量边界
     * 使用extends定义类型变量上界，用于限制类型范围。类型变量无法定义下界
     * 可以为类型变量定义多个上界，多个上界用&连接，多个上界中只能有一个类，可以有多个接口。类位于接口之前
     * 当为类型变量定义上界后，通过类型变量可以调用上界类型中的方法
     *
     * 通配符?
     * 实际类型参数列表中?表示未知类型，使用extends定义通配符上界，使用super定义通配符下界
     * 不使用通配符情况下，实际类型参数列表不同的参数化类型无关联，不具有继承关系
     * 使用通配符情况下，可以建立实际类型参数列表不同的参数化类型间的继承关系
     *
     * 泛型擦除
     * 将泛型类，泛型接口，泛型方法中类型变量替换为第一边界，若未指定边界替换为Object
     */

    public static void main(String[] args) {
        Map<String,String> map = new HashMap<String,String>();

    }
}
